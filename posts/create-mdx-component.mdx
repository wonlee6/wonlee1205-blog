---
title: 'MDX Component 적용해보기기'
date: '2025-04-21'
description: '블로그에 작성되는 포스팅 글을 mdx 컴포넌트로 만들어 보기기'
tags: ['Next', 'contentLayer']
---

# MDX로 블로그 글 작성하기

`MDX`란 Markdown에서 JSX를 사용할 수 있게 해주는 문서 포맷입니다. 기존 .md 문법을 그대로 유지하면서도, React 컴포넌트를 삽입할 수 있어 동적인 블로그 포스트 작성이 가능합니다.

필요로 하는 패키지 설치 (`Next.js` 기준)

```bash
npm install @mdx-js/react contentlayer2 next-contentlayer2
```

[Contentlayer](https://contentlayer.dev/)는 콘텐츠를 타입이 지정된 JSON 데이터로 변환하여 애플리케이션에서 쉽게 사용할 수 있게 해주는 SDK입니다.
`contentlayer2`는 `Contentlayer`를 래핑한 라이브러리로, 최신 Next.js와의 호환성을 위해 사용합니다.

장점:

- 가볍고 사용하기 쉬움
- 뛰어난 개발자 경험
- 매우 빠른 빌드 및 페이지 성능

> Contentlayer에 대한 자세한 설명은 [이 글](https://contentlayer.dev/blog/working-with-content-is-hard-for-developers)을 참고하세요.

## MDX 설정하기

1. **next.config** 설정

```js showLineNumbers
// next.config.mjs
import { withContentlayer } from 'next-contentlayer2'

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  pageExtensions: ['ts', 'tsx', 'js', 'jsx', 'md', 'mdx'],
  experimental: {
    mdxRs: true
  }
}

const configWithContentlayer = withContentlayer(nextConfig)

export default configWithContentlayer
```

2. **contentlayer.config** 파일 생성

루트 디렉터리에 `contentlayer.config.ts`를 생성합니다.

```ts showLineNumbers
import { defineDocumentType, makeSource } from 'contentlayer2/source-files'
import { type Options, rehypePrettyCode } from 'rehype-pretty-code'

export const Post = defineDocumentType(() => ({
  name: 'Post',
  contentType: 'mdx',
  filePathPattern: `**/*.mdx`,
  fields: {
    title: { type: 'string', required: true },
    date: { type: 'date', required: true },
    description: { type: 'string', required: true },
    readTime: { type: 'number' },
    coverImage: { type: 'string' },
    tags: { type: 'list', of: { type: 'string' }, required: true }
  },
  computedFields: {
    url: {
      type: 'string',
      resolve: (post) => `/blog/${post._raw.flattenedPath}`
    },
    slug: {
      type: 'string',
      resolve: (post) => post._raw.flattenedPath
    }
  }
}))

export default makeSource({
  contentDirPath: 'posts',
  documentTypes: [Post]
})
```

주요 항목 설명:

- `defineDocumentType`: 문서 타입(Post)을 정의
- `fields`: MDX 파일의 메타데이터

| 필드명      | 타입           | 필수 여부 | 설명                         |
| ----------- | -------------- | --------- | ---------------------------- |
| title       | string         | ✅        | 게시물 제목                  |
| date        | date           | ✅        | 게시물 작성 날짜             |
| description | string         | ✅        | 게시물 설명                  |
| readTime    | number         | ❌        | 읽는 데 걸리는 시간(분 단위) |
| coverImage  | string         | ❌        | 썸네일 이미지 경로           |
| tags        | list of string | ✅        | 태그 배열                    |

- `computedFields`: URL 및 슬러그 자동 생성
- `makeSource`: Contentlayer 설정을 바인딩
- `computedFields` - **계산된 필드**:

  - `url`: 라우팅용 블로그 URL 생성
  - `slug`: 경로 기반 slug (ex: tech/how-to-mdx)

- `makeSource` - **전체 설정 바인딩**
  - `contentDirPath`: `posts` 폴더를 기준으로 콘텐츠를 로드
  - `documentTypes`: 정의된 문서 타입(Post) 적용
  - `mdx`: MDX 렌더링 관련 설정(remark/rehype 플러그인 포함)

## MDX 렌더링 설정

다음 패키지를 설치합니다.

```bash
npm i -D rehype-pretty-code rehype-slug remark-gfm rehype-autolink-headings
```

그리고 설정 파일에 플러그인을 추가합니다.

```ts showLineNumbers
export default makeSource({
  contentDirPath: 'posts',
  documentTypes: [Post],
  mdx: {
    remarkPlugins: [remarkGfm],
    rehypePlugins: [rehypeSlug, [rehypeAutolinkHeadings, { behavior: 'wrap' }], rehypePrettyCode]
  }
})
```

## MDX 파일 작성

`/posts` 폴더에 `.mdx` 파일을 생성합니다.

````md
---
title: 'React Hooks 가이드'
date: '2025-05-21'
description: 'React Hooks를 활용한 상태 관리와 사이드 이펙트 처리 방법을 알아봅니다.'
tags: ['React', 'Hooks', 'JavaScript']
---

# React Hooks 마스터하기

React Hooks는 함수형 컴포넌트에서 상태와 생명주기 기능을 사용할 수 있게 해주는 기능입니다.

## 기본 Hooks

### useState

```jsx
import { useState } from 'react'

function Counter() {
  const [count, setCount] = useState(0)

  return (
    <div>
      <p>카운트: {count}</p>
      <button onClick={() => setCount(count + 1)}>증가</button>
    </div>
  )
}
```
````

## Contentlayer 빌드 스크립트

`package.json`에 다음 명령어를 추가합니다.

```json
// package.json
"scripts": {
  "build:content": "contentlayer2 build"
}
```

빌드 후 `.contentlayer` 폴더가 생성되며, 타입 정의 및 데이터를 확인할 수 있습니다.

```ts showLineNumbers
// .contentlayer/generated/index.d.ts
// NOTE This file is auto-generated by Contentlayer

import { Post, DocumentTypes, DataExports } from './types'
import { SourceProvideSchemaErrorJSON, SourceFetchDataErrorJSON } from 'contentlayer2/core'

export * from './types'

export declare const allPosts: Post[]

export declare const allDocuments: DocumentTypes[]

// .contentlayer/generated/types.d.ts
export type Post = {
  /** File path relative to `contentDirPath` */
  _id: string
  _raw: Local.RawDocumentData
  type: 'Post'
  title: string
  date: IsoDateTimeString
  description: string
  readTime?: number | undefined
  coverImage?: string | undefined
  tags: string[]
  /** MDX file body */
  body: MDX
  url: string
  slug: string
}
```

## tsconfig 설정 (TypeScript 사용 시)

```ts showLineNumbers {2, 7, 14}
// tsconfig
"baseUrl": ".",
"paths": {
  "@/*": [
    "./*"
  ],
  "contentlayer/generated": ["./.contentlayer/generated"]
},
"include": [
  "next-env.d.ts",
  "**/*.ts",
  "**/*.tsx",
  ".next/types/**/*.ts",
  ".contentlayer/generated"
],
```

## MDX 데이터 불러오기

```tsx
// app/page.tsx
...
import { allPosts } from '.contentlayer/generated'

export default function Home() {
  console.log("allPosts", allPosts)
  return (
    ...
  )
}
```

다이나믹 라우트에서 불러오기

```tsx showLineNumbers
// app/post/[slug]/page.tsx
export default async function PostPage({ params }: { params: Promise<{ slug: string }> }) {
  const slug = (await params).slug
  const post = allPosts.find((post) => post._raw.flattenedPath === slug)
  ...
```

## 커스텀 컴포넌트 적용

스타일 정의

```tsx showLineNumbers
 // components/ui/index.tsx
import type { MDXComponents } from 'mdx/types'
import { PropsWithChildren } from 'react'

const components: MDXComponents = {
  h1: (props: React.HTMLAttributes<HTMLHeadingElement>) => (
    <h1 {...props} className='scroll-m-20 text-4xl font-extrabold tracking-tight lg:text-5xl'>
      {props.children}
    </h1>
  ),
  h2: (props: React.HTMLAttributes<HTMLHeadingElement>) => (
    <h2
      {...props}
      className='scroll-m-20 border-b pb-2 text-3xl font-semibold tracking-tight first:mt-0'>
      {props.children}
    </h2>
  ),
  p: (props: React.HTMLAttributes<HTMLParagraphElement>) => (
    <p {...props} className='leading-7 [&:not(:first-child)]:mt-6'>
      {props.children}
    </p>
  ),
  blockquote: (props: React.BlockquoteHTMLAttributes<HTMLQuoteElement>) => (
    <blockquote {...props} className='mt-6 border-l-2 pl-6 italic'>
      {props.children}
    </blockquote>
  )
  ...
}

export default components
```

이렇게 마크다운 형식을 `html`으로 변환하면서 만들어진 `html tag`에 대해 스타일을 정의할 수 있습니다.

## MDX 렌더링 컴포넌트

`props`로 전달받은 `code`를 `useMDXComponent`훅을 이용해 앞서 정의한 컴포넌트들을 만들도록 합니다.

```tsx showLineNumbers
// components/mdx-component.tsx
'use client'

import React from 'react'
import { useMDXComponent } from 'next-contentlayer2/hooks'
import components from './ui'

export default function MDXComponent({ code }: { code: string }) {
  const MDXCompo = useMDXComponent(code)

  return <MDXCompo components={components} />
}

// app/post/[slug]/page.tsx
...
return (
  ...
  <MDXComponent code={post.body.code} />
  ...
)
```

## React 컴포넌트 사용 예시

`Alert` 컴포넌트 정의

```tsx showLineNumbers
// components/alert.tsx
type AlertProps = {
  children: React.ReactNode
  type?: 'info' | 'warning' | 'error'
}

export default function Alert({ children, type = 'info' }: AlertProps) {
  const base = 'p-4 my-4 rounded font-semibold border-l-4'
  const typeClass =
    type === 'info'
      ? 'bg-blue-50 border-blue-400 text-blue-700'
      : type === 'warning'
        ? 'bg-yellow-50 border-yellow-400 text-yellow-800'
        : 'bg-red-50 border-red-400 text-red-700'

  return <div className={`${base} ${typeClass}`}>{children}</div>
}

// .mdx
...
<Alert type="info">
  이건 <b>info</b> 타입의 Alert입니다!
</Alert>

<Alert type="warning">
  이건 <b>warning</b> 타입의 Alert입니다!
</Alert>

<Alert type="error">
  이건 <b>error</b> 타입의 Alert입니다!
</Alert>
...

// components/ui/index.tsx
const components: MDXComponents = {
  h1: (props: React.HTMLAttributes<HTMLHeadingElement>) => (
    <h1 {...props} className='scroll-m-20 text-4xl font-extrabold tracking-tight lg:text-5xl'>
      {props.children}
    </h1>
  ),
  ...
  Alert
}
```

![설명](/images/alert-image.png)

여기까지가 MDX를 활용해 블로그 포스트를 작성하고, 커스텀 컴포넌트를 적용하는 기본적인 흐름입니다.
코드 하이라이트와 라인 넘버 등 추가 설정은 [rehype-pretty-code](https://rehype-pretty.pages.dev/) 문서를 참고하세요.

> .gitignore에 .contentlayer 등록해도 됩니다.
